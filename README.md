# Hybrid TSP Solver

This repository contains my implementation of a hybrid TSP solver for my master's thesis. I named it **hybrid** because it combines the classical 1Tree branch and bound proposed by [Held and Karp](https://pubsonline.informs.org/doi/10.1287/opre.18.6.1138) with the Graph Convolutional Network proposed by [Joshi, Laurent, and Bresson](https://arxiv.org/abs/1906.01227). In the [`src`](./src) folder, you can also find a Cplex TSP solver that I developed to verify the correctness of the hybrid one.

## Idea 

My approach involves using the Graph Conv Net to preprocess the input Graph to create a distance matrix file. Each entry in this file will be a pair $(w_{ij}, p_{ij})$, where $w_{ij}$ is the weight of the Edge between nodes $i$ and $j$, computed as the euclidean distance, and $p_{ij} \in [0,1]$ is the probability, obtained by the neural network, that the corresponding Edge is part of the optimal tour. I will leverage this probabilistic information to expedite the exploration of the branch and bound tree.

## 1-Tree Branch and Bound

To improve efficiency, the original 1-Tree Branch and Bound approach proposed by Held and Karp was not implemented. Instead, a modified version, well described in the [Valenzuela and Jones](https://www.sciencedirect.com/science/article/abs/pii/S0377221796002147?via%3Dihub) paper, was used. For each Node in the branch-and-bound tree, the associated 1-Tree is reformulated by performing a linear number of dual ascent steps to enhance the lower and upper bounds.

## Graph Convolutional Network

I utilized the pre-trained Graph Conv Nets that Joshi released in the [official repository](https://github.com/chaitjo/graph-convnet-tsp) of the paper. These networks were trained on one million instances of Euclidean TSP, with cities sampled from the range $[0,1] \times [0,1]$ and sizes of 20, 50, and 100 nodes. The edge embeddings from the last convolutional layer were transformed into a **probabilistic adjacency matrix** using a multi-layer perceptron with softmax.

## Neural Grafting

The hybrid solver obtains the probabilities for each Edge of being in the solution using a Graph Conv Net, it then assigns to a 1-Tree the probability of being the optimal tour by averaging the probabilities of its edges. It then uses these values as follows:
1. **Candidate node selection**: to construct a 1Tree, a **candidate Node** must be chosen. The algorithm tries all nodes as the candidate node and select the one that yields the best lower bound. If multiple nodes produce the same lower bound, the one with the highest probability is chosen;
2. **Probabilistic nearest neighbor**: the algorithms needs an initial feasible solution to prune the search space using the bounding step. In the classical solver, this is accomplished by executing the nearest neighbor algorithm with each node as the starting node and then selecting the lowest tour found as the initial tour. The hybrid solver also uses a prob-nearest-neighbor algorithm. Starting from each node, it selects at every step the unvisited node that is linked to the current one by the edge with the highest probability. The tour found with this algorithm is then compared with the one returned by the nearest neighbor, and the best one is used as the initial feasible solution;
3. **Best-Prob-First search**: all subproblems generated by the branching step are stored and sorted from lowest to highest. In the Hybrid Solver when two subproblems have the same value, the one with the highest probability is selected first. This procedure is extremely flexible, as it provides meta-parameters that allow for the modification of the subproblems sorting criterion, enabling any desired trade-off between the probability and the value of 1Trees.

## Code Documentation
All code documentation was completed using [Doxygen](https://www.doxygen.nl/), and is accessible in both [online](https://www.lorenzosciandra.com/assets/projects/HybridTSPSolver/index) and [PDF](./res/docs/code_documentation.pdf) formats.

## Results
Below are the mean values obtained from 100 instances for each graph size. The best value in each comparison is highlighted in bold:

|                           | **Classic Solver** | **Hybrid Solver** |
|---------------------------|--------------------|-------------------|
|   *100 nodes*            *100 instances*       *max 10 minutes*  |||
|                           |                    |                   |
| Total time (s)            | 62.560             | **25.858**        |
| B-&-B time (s)            | 62.089             | **20.139**        |
| Time to Best (s)          | 44.781             | **39.935**        |
|							|					 |					 |
| B-&-B tree depth          | 13.58              | **7.86**          |
| Depth of the best         | 9.45               | **3.45**          |
|							|					 |					 |
| Generated B-&-B nodes     | 2094.38            | **757.8**         |
| Explored B-&-B nodes      | 1318.67            | **507.72**        |
| B-&-B nodes before best   | 1049.65            | **371.09**        |
|							|					 | 					 |
| Best value                | 7.795              | 7.795             |
| Probability of the best   | -                  | 0.988             |